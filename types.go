package dice

import (
	"context"

	"gopkg.in/yaml.v2"
)

// Model interface satisfies the the dice model requirements
// To become a dice model the caller must be able to
// convey their column-field bindings as ColumnLit, their
// primary key and the table that they satisfy.
type Model interface {
	// ColumnList returns the name of implementer's fields
	// in the order that their table is created.
	ColumnList() []string
	// PK is the definition of the table's primary key
	// and returns it's column name.
	PK() string
	// TableName returns the name of the table that the
	// implementer satisfies.
	TableName() string
}

// BaseStmt determines the methods that a dice ORM  must be
// able to interact with. It generally defines the CRUD
// interaction with the target driver.
type BaseStmt interface {
	// Target takes in a struct{} that implements
	// the dice.Model interfece as the target to
	// represent the record of a table.
	Target(interface{}, ...context.Context) BaseStmt
	// Find let's you find the record that you seek by
	// accepting the FilterStmt specific to your driver
	// and a SequenceStmt specifying the order of the
	// result set.
	Find(FilterStmt, SequenceStmt) error
	// Create creates a record inside the table of
	// model given by the Target() method.
	Create() (Result, error)
	// Update updates the record depending upon the
	// FilterStmt you have provided
	Update(FilterStmt) error
	// Delete deletes the record from the targer table
	// depending upon the FilterStmt provided
	Delete(FilterStmt) error
}

// FilterStmt defines basic methods that the records can be
// used to get filtered. FilterStmt is the only way to add
// conditions to the BaseStmt.
type FilterStmt interface {
	// Match only matches the the records in your database
	// with the slice of conditions provided as the parameter.
	// Slice of FieldData are the conditions to match the
	// the data from.
	Match([]FieldData)
	// Chunk limits or offsets the data. In any case it returns
	// a chunk of the whole recordset. It is used to paginate
	// your recordset.
	Chunk(int, int)
	// Field let's you take action ona single field of your table.
	// It returns a columnDataHolder which is an internal type of
	// dice, that provides a terminal operation called Must().
	// So it reads like Field("name").Must(dice.Eq, "Ashish").
	Field(string) *columnDataHolder
	// Pick lets you select only the columns that you require
	// It is equivalent to SELECT (*) in SQL databases and
	// $projection in Mongo
	Pick(...string)
}

// SequenceStmt determines the sequence in which the data from
// the filtered stmt be returned.
type SequenceStmt interface {
	// Asc takes a column name as parameter and sorts the
	// record in the ascending order of that column.
	Asc(...string)
	// Desc takes a column name as parameter and sorts the
	// record in the descending order of that column.
	Desc(...string)
}

// Result corresponds to sql.ReResult interface
type Result interface {
	// LastInsertId returns the integer generated by the database
	// in response to a command. Typically this will be from an
	// "auto increment" column when inserting a new row. Not all
	// databases support this feature, and the syntax of such
	// statements varies.
	LastInsertId() (int64, error)

	// RowsAffected returns the number of rows affected by an
	// update, insert, or delete. Not every database or database
	// driver may support this.
	RowsAffected() (int64, error)
}

// ConnectURI is the generalized struct for connecteing to your
// database drivers.
type ConnectURI struct {
	Host     string `yaml:"host" json:"host"`
	Port     int    `yaml:"port" json:"port"`
	Database string `yaml:"db" json:"db"`
	Username string `yaml:"username" json:"username"`
	Password string `yaml:"password" json:"password"`
	SSL      bool   `yaml:"ssl" json:"ssl"`
}

// Structure is the definition of properties of a column. A dice
// field is nothing but the column of your table with it's
// structure definition provided inside `${tableName}.dice`.
type Structure struct {
	// The reason why these fields have json tags is because after
	// we get yaml.MapSlice we want to unmarshal column values
	// as dice.Structure
	Type          string `json:"type"`
	TablePK       bool   `json:"table_pk"`
	Unique        bool   `json:"unique"`
	AutoIncrement bool   `json:"auto_increment"`
	IsNotNull     bool   `json:"not_null"`
	Default       string `json:"default"`
	Constraint    string `json:"constraint"`
	Using         string `json:"using"`
	Ignore        bool   `json:"ignore"`
	// Mixins        []string `yaml:"mixins"`
}

// Schema defines your database table/collection. The schema definition
// is defined insde file.dice where file is your table name. The dice
// files is located inside source folder of your file system from which
// the target application compiles into the file.go dice Models.
type Schema struct {
	Table             string        `yaml:"table"`
	ModelName         string        `yaml:"model"`
	ShouldCreateDates bool          `yaml:"create_dates"`
	OrderedColumns    yaml.MapSlice `yaml:"columns"`
	ColumnAttrs       map[string]Structure
}

// The Options present in config.toml
type Options struct {
	// Specifies for which dialect the models are being
	// generated. Without this config dice migrations will
	// not work.
	Dialect     DriverIdent `yaml:"dialect"`
	Source      string      `yaml:"source"`
	Destination string      `yaml:"destination"`
	// Actions tells the compiler while running the
	// migrations you can look for additions in
	// columns or deletion of columns or not.
	// This will run CREATE COLUMN IF NOT EXISTS and
	// set it up automatically or deletes it if
	// cache has it and latest source does not.
	Actions struct {
		LookForAdditions bool `yaml:"no_additions"`
		LookForDeletions bool `yaml:"no_deletions"`
	} `yaml:"actions"`
	// Verbose tells compiler to log everything
	Verbose     bool       `yaml:"verbose"`
	Credentials ConnectURI `yaml:"credentials"`
}
